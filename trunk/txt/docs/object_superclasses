======================================================================================================
======================================================================================================

OBJECT SUPERCLASSES AND BEHAVIOURS

Objects are defined not only by the way that other objects interact with them (as is handled by the
core object interfaces), but also the way that they interact with other objects. To handle the way
that objects act, a set of object superclasses have been implemented so that game objects can easily
extend these classes and save a lot of redundant code.

In other words, the object superclasses control how the object acts, while the object interfaces only
define how they react. Note the difference between controlling and defining, as the interfaces have no
say in what the methods do, but only state that they exist.

======================================================================================================

CORE SUPERCLASSES:

These classes all inherit off each other and are the three basic classes that control all objects in
the game, affecting how the object is displayed, how it moves, and how it can be checked for collision
(as implied by the file names). It is critical to understand these methods and how they can be used in
order to control the object internally, in contrast to the object interfaces which are used to control
the objects externally.

(*)	)=================================================================================================

	dmcigd.core.objects.AnimationHandler.java
	
	As the name suggests, AnimationHandler handles animations, and by extension, deals with object
	spritesheets. It controls the animation sequence and current frame, as well as the advancement of
	frames.
	
	PUBLIC GETTERS
	
	->	int getSequence()
			Returns the animation sequence (spritesheet row)
			Can also be used to check object's state (rather than creating another property or enum
			in the object)
	
	->	int getFrame()
			Returns the animation frame (spritesheet row) as an integer
			Can also be used to check an object's status, similar to getSequence()
	
	->	boolean flipped
			This public boolean (bad practice, I know, I'll fix this eventually) simply stores a
			flipped state. By passing it's value onto an associated ObjectImage, it can be determined
			whether or not to flip the x variables, effectively flipping the image horizontally.
	
	PUBLIC SETTERS
	
	->	void setFrame(int frame)
			Sets the current frame
			
	->	void setSequence(int sequence)
			Sets the current sequence
			If the sequence changes, also resets the frame to 0
			  *	If using an object design pattern that relies on sequences and frames to store state
				or status, keep this behaviour in mind, or override the method
				
	->	void setFramelimits(int[] frameLimits)
			Sets the lengths of the animation where [SequenceIndex] => SequenceLength
			
	->	void setFrameSpeed(float frameSpeed)
			Sets speed of frame advancement. Considering that game ticks are far faster than animation
			speeds, this is usually set to a float of value < 1 (where the frame increments by
			frameSpeed with each animate() call, which is typically once per tick)
			
	->	void setAnimationLoops(boolean[] animationLoops)
			Sets whether or not the animation should loop at last frame. Similar to above, where
			[SequenceIndex] => LoopsBoolean
				
	
	OTHER METHODS
	
	->	void animate()
			This method advances to the next frame by adding the frameSpeed to the current frame.
			It is important to note that the frame and framespeed are both floats, so each tick it is
			possible to advance the frame by values of less than one.
			
			Once the frame reaches the limit, if the animation loops, the frame is reset back to 0.
			
			If the frame does not loop, it simply does not advance.
			
	OTHER NOTES
	
			SPRITESHEET LAYOUT
			
				FRAMES
			0 1 2 3 4 5 7 8 9			FrameLimits {
	S	  0	a b c d e f g					8, 4, 2, 2,
	E	  1 a b c d							10, 9, 1, 1,
	Q	  2 a b								10 }
	U	  3 a b 
	E	  4 a b c d e f g h i
	N	  5 a b c d e f g h
	C	  6 a
	E	  7 a
	S	  8 a b c d e f g h i
	
	All visible objects are considered to be animated at a technical standpoint, although non-animated
	objects are simply single frame objects that never advance frames.
	
	For example, if I wanted to store 4 colours of static blocks in one spritesheet:
	
		SPRITESHEET
		
		  0 1 2 3
		0 A B C D
		  
		To get a block of colour C:
			setSequence(0);
			setFrame(2);
	
	This technique can also be used to store multiple sprites on a single image, if they are used in
	conjunction. To do this, one must establish a constant image width and image height, and simply
	reference the according sequence and frame, as these, in practice, are nothing more than source
	image positions.
	
	Through clever use of the animate() call and frameSpeeds, there is a lot of possibility for purely
	matrix-based and mathematical object state control that is synchronized directly with the object's
	display sprite, however I'll leave that up to you to figure out as those cases would be absurdly
	specific, although mathematically gorgeous.
			

(*)	)=================================================================================================

	dmcigd.core.objects.VisibleObject.java
	
		extends dmcigd.core.objects.AnimationHandler.java
	
	VisibleObject.java controls how an object is displayed, including image resources, position, and
	visibility checks. This abstract class acts as nothing more than a bundle of properties, with a
	couple of very basic calcuations to determine relative positions
	
	PUBLIC GETTERS
	
	->	String getImagePath()
			Returns the path of the object's associated spritesheet
			
	->	int getX()
			Returns the x position
			
	->	int getY()
			Returns the y position
			
	->	int getDX()
			Returns the x displacement
			
	->	int getDY()
			Returns the y displacement
			
	->	int getHeight()
			Returns the bounding box height
		
	->	int getWidth()
			Returns the bounding box width
			
	->	int getImageHeight()
			Returns the image height
			
	->	int getImageWidth()
			Returns the image width
			
	->	int relX(int viewX, int viewY)
			Uses the player's position to determine the x position of the viewing area
			Returns the object's position relative to the viewing area
			
	->	int relY(int viewX, int viewY)
			Uses the player's position to determine the y position of the viewing area
			Returns the object's position relative to the viewing area
			
	->	ObjectImage getObjectImage(int viewX, int viewY)
			Returns an ObjectImage instance of the current object
			See extra_information for more info on the ObjectImage.java class
			
	PUBLIC SETTERS
	
	->	void setImagePath(String imagePath)
			Sets the path of the object's associated spritesheet
			Typically called only once upon object construction
			
	->	void setX(int x)
			Sets the x position of an object
			Also sets the object's displacement by finding the difference in x
			
	->	void setY(int y)
			Sets the y position of an object
			Also sets the object's displacement by finding the difference in y
			
	->	void setDX(int dx)
			Directly sets the object's x displacement
			Used to "fake" drag on a surface, pushing Entity's off, or to do the opposite, by setting
			the displacement to 0 and ignoring the object's movement.
			
	->	void setDY(int dy)
			Directly sets the object's y displacement
			Same as above
			
	->	void setHeight(int height)
			Sets the object's bounding box height
			
	->	void setWidth(int width)
			Sets the object's bounding box width
			
	->	void setImageHeight(int imageHeight)
			Sets the object's image height
			
	->	void setImageWidth(int imageWidth)
			Sets the object's image width
			
	OTHER NOTES
	
	It is important to understand how bounding boxes and positions work mathematically, as only a
	single pair of position integers is set.
	
	First and foremost, it should be common knowledge that with computers, the x and y value always
	refers to the top left. Therefore, rather than running right and up like a coordinate grid, values
	run right and down like a table of values.
	
	  0 1 2 3 4 5 6
	0						A.x = 2
	1     A					A.y = 1
	2
	3
	
	Next, it is important to note that in this game, position refers to the top left of the bounding
	box. It is also important to note that the bounding box is always positioned in the bottom center
	of the image, with 2px of padding at the bottom for overlap with the ground.
	
	It is also important to note that images are all scaled up by a factor of 2, meaning that they are
	4x as large as their image resource.
	
	This diagram uses a scale of 2, simulating real pixels:
	
	  0 1 2 3 4 5 6 7 8 9			& top-left pixel (position)
	0								# bounding box
	1     x x x x x x x x			x image bounds
	2     x x x x x x x x
	3     x x x x x x x x			x = 8 (note the scale of 2)
	4     x x x x x x x x			y = 10
	5     x & # # # # # x			height = 8
	6     x # # # # # # x			width = 12
	7     x # # # # # # x			imageHeight = 18
	8     x # # # # # # x			imageWidth = 16
	9     x x x x x x x x
	
	General style notes are to ensure that hostile bounding boxes leave adequate padding (to make the
	game easier and give more leeway for the player) while friendly bounding boxes should be very
	close to the image's bounding box (usually leaving just 2px of padding on the bottom and nothing
	more.

(*)	)=================================================================================================

	dmcigd.core.objects.ObjectCollision.java
	
		extends dmcigd.core.objects.VisibleObject.java
		
	This class handles all methods relating to collision checks, and is inherited by all game objects
	that are not static, as all game objects must be stored in their relative linked lists which are
	used in collision checks, and therefore require collision methods in their interfaces.
	
	PUBLIC GETTERS
	
	->	Rectangle getBounds(int vx, int vy)
			Returns a rectangle object of an object's bounding box at it's destination (after moving
			the amount of its x and y velocities)
			
	->	Rectangle getBounds()
			Overrides the above method to return the object's current bounding box
			
	->	CollisionType getCollisionType()
			Returns the object's collisionType, as defined in the CollisionType enumerator
	
	PUBLIC SETTERS
	
	->	void setCollisionType(CollisionType collisionType)
			Sets the object's collisionType, as defined in the CollisionType enumerator
			Typically called only once upon object construction
	
	OTHER METHODS
	
	->	void onRest(EntityType entityType)
			Blank method to satisfy interface requirements
			
	->	void onUnrest(EntityType entityType)
			Blank method to satisfy interface requirements
			
	->	void onPush(Entity entity, int v)
			Blank method to satisfy interface requirements
			
	->	void onAttack(int damage, boolean flipped)
			Blank method to satisfy interface requirements

(*)	)=================================================================================================

	dmcigd.core.objects.MovingObject.java
	
		extends dmcigd.core.objects.ObjectCollision.java
		
	This class handles motion vectors, including simple displacement, velocity vectors, acceleration
	vectors, and gravity. Please note that this class does not handle motion itself, it simply handles
	the vectors and properties associated with movement. Each object should define it's owh movement
	properties, or inherit from a superclass such as Entity.java
	
	PUBLIC GETTERS
	
	->	int getVX()
			Returns instantaneous x velocity as an integer
			
	->	int getVY()
			Returns instantaneous y velocity as an integer
			
	->	float getAX()
			Returns instantaneous x acceleration
			
	->	float getAY()
			Returns instantaneous y acceleration
	
	PUBLIC SETTERS
	
	->	void addX(int dx)
			Shorthand method to move an object by a defined x displacement
	
	->	void addY(int dy)
			Shorthand method to move an object by a defined y displacement
			
	->	void setVX(float vx)
			Sets the x velocity
			
	->	void setVY(float vy)
			Sets the y velocity
			
	->	void setAX(float ax)
			Sets the ax velocity
			
	->	void setTUp(float tUp)
			Sets the upward terminal velocity
			
	->	void setTDown(float tDown)
			Sets the downward terminal velocity
			
	->	void setTLeft(float tLeft)
			Sets the leftward terminal velocity
			
	->	void setTRight(float tRight)
			Sets the rightward terminal velocity
			
	->	accelerate(float rate, float terminal, Direction direction)
			Creates an acceleration velocity with an assigned magnitude and direction
			Also sets the terminal velocity for said vector
		
	->	setGravity()
			Sets a gravity vector that is standard across all objects
			This is an acceleration of 0.4 pixels / tick ^ 2
				with a terminal velocity of 5 pixels / tick
				and a downward direction
	
	OTHER METHODS
	
	->	addAcceleration()
			This method tells the object to actually apply it's motion vectors and properties, and is
			meant to be run once per tick
			It adds the acceleration to the velocities, and does a check against the terminal
			velocities to ensure that no object is defying it's own physical laws

======================================================================================================

ENTITY SUPERCLASSES:

The entity superclass is a very difficult class to understand as it handles a significant portion of
the game logic (that is, the interaction between solid objects), which has to be consistent across the
game, but at the same time, abstract enough to allow for unique applications of the engine. The useful
methods have fairly self-explanatory method names, so the easiest way to learn how to use the Entity
superclass is to look at the source code and applications of the core Entity objects such as players,
items, projectiles, monsters, and pushable blocks.

Originally the Entity class was a massive clusterfuck of a god object, sort of like DmciGD.java (yes,
this is bad practice, do as I say, not as I do). It has since been split into three smaller classes.
Please note that these classes aren't very useful on their own, simply due to the way they call their
parent methods. It isn't nearly abstract enough for my liking, so it should be noted that Entity is
split into three classes purely due for organization, and does not fall into any true design pattern.

Also note that I don't write these long explanations and comments for no reason. If anybody has a
solution to this issue, I'd love to hear it so we can fix this ugly code. My only fear is, considering
my lack of previous experience, it may not be possible to fix this issue just because the game is
structured poorly in itself.

(*)	)=================================================================================================

	dmcigd.core.objects.ObjectCollider.java
	
		extends dmcigd.core.objects.MovingObject.java
		
	This class handles all methods having to do with colliding with another object. Please note that
	while ObjectCollision.java handles object collision, that is, how to check if two objects are
	colliding and what to do if collision occurs, ObjectCollider actively collides with other objects.
	That is, it handles the calling of the appropriate collision methods in ObjectCollision.
	
	Please note that the significance of this class is the affect that it has on object movement. It
	is fairly simple to directly deal with object collision through the ObjectCollision class, and
	only requires a 3-condition if statement as seen in the objectsCollide() method. However, this
	class also deals with CollisionTypes and motion obstruction, which is important to almost all
	implementations of the Entity class with the exception of SimpleProjectiles.
	
	PUBLIC PROPERTIES
	
	->	RestableObject restingBlock
			This object is used to store the object that the Entity is currently resting on, which is
			particularly important for getting properties such as displacement for movement.
	
	->	RestableObject restingBlockCheck
			This object is used to temporarily store the resting object during collision checks. It's
			a countermeasure to ensure that one onRest() is called per onUnrest(), and that only one
			onRest() is called at a time.
	
	PUBLIC SETTERS
	
	->	void setSolidObjects(ArrayList<SolidObject> solidObjects)
			In order to check collision, a list of objects to check against is required. As such, it
			is necessary to pass down the solidObjects ArrayList to all Entities, so that collision
			checks can be made
	
	ABSTRACT METHODS (DEFINED IN ENTITY)
	
	->	void rest(CollisionType collisionType)
			Not to be confused with restObject(), this method handles basic resting properties based
			on the collisionType. This property is shared with the later BlockMapCollider object.
			
	->	void pushObject(SolidObject object, int v)
			This method is called every time object "pushing" occurs, as explained in the object
			interfaces. It is defined in the Entity class to do nothing more than call the target
			object's onPush() method, however, is defined as its own method in order to allow for more
			complicated interaction between objects.
			
	->	void restObject()
			Not to be confused with rest(), this is much like pushObject(), but applies to the resting
			block and onRest() method.
			
	->	void unrestObject()
			Same as above, but acts onUnrest()
			
	COLLISION METHODS
		
	->	boolean objectsCollide(Rectangle boundingBox, SolidObject object)
			Returns true if the bounding box collides with a solid object.
			
			Two conditions must be true for the objects to be considered as colliding:
			
			1.	The bounding box intersects with that of the target object
			
					AND
			
			2.	The target object is the current restingBlock.
					You are assumed to be colliding with the object you are resting on in order to
					properly determine your restingBlock for the next frame.
				
					OR
					
				The object's current bounding box (before movement, determined by getBounds() method)
				does not intersect with that of the target object.
					This ensure that it does not count as collision if you are somehow inside of the
					object, saving a lot of trouble with the specific collision check methods, and
					opening the door for directionally sensitive collision checks.
	
	COLLISION CHECKS
	
	Please note that a different method is called for upwards, downwards, and horizontal collision
	as they all behave in different ways.
					
					
	->	void checkSolidObjectCollisionDown(int v)
	
		First, the method establishes a bounding box of the target destination, which is called by
		getBounds(0,v+1). The +1 is necessary in order to make a neglible difference in actual
		collision behaviour, but important in ensuring that the object directly beneath the bounding
		box is checked, as vertical velocity will often be equal to 0. This is very important for
		checking the restingBlock and behaving accordingly (especially in the case of moving blocks).
		
		Next, the method loops through the list of SolidObjects and checks for collision using the
		objectsCollide() method mentioned above. A different course of actions is taken depending on
		the object's CollisionType:
		
		If the object is of CollisionType SOLID or PLATFORM, the following course of action is taken:
			
		1.	Sets the restingBlockCheck to the target object.
			
		2.	Sets the current Y position such that the bottom of the entity hits is at the top of the
			target object
				
		3.	Sets the Y velocity to 0 and sets the local obstructMovement boolean to true, used later.
			
		Once all of the objects have been checked, the method checks the obstructMovement boolean. If
		the value is still set to false, that means no object has obstructed the movement and the
		Entity is to advance as usual, by adding the y velocity to the y value, i.e. addY(v)
		
	
	->	void checkSolidObjectCollisionUp(int v)
	
		First, the method establishes a bounding box of the target destination, which is called by
		getBounds(0,v+1). The +1 is necessary for the same reasons as explained above. Although this
		may seem like a measure only necessary for downward collision, it is also important for any
		moving block that will push the Entity upwards.
		
		Next, the method loops through the list of SolidObjects and checks for collision using the
		objectsCollide() method mentioned above.
		
		If the object is the resting block, the restingBlockCheck is set to the target object.
		
		If the object is of CollisionType SOLID, the following course of actions taken:
			
		1.	Sets the current Y position such that the top of the entity hits is at the bottom of the
			target object.
				
		2.	Sets the Y velocity to 0 and sets the local obstructMovement boolean to true, used later.
			
		Once all of the objects have been checked, the method checks the obstructMovement boolean. If
		the value is still set to false, that means no object has obstructed the movement and the
		Entity is to advance as usual, by adding the y velocity to the y value, i.e. addY(v)
		
	
	->	void checkSolidObjectCollisionX(int v)
	
		First, the method establishes a bounding box of the target destination, which is called by
		getBounds(v,0).
		
		Next, the method loops through the list of SolidObjects and checks for collision using the
		objectsCollide method.
		
		For all objects that are collided with, the pushObject() method is called.
		
		If the object is of CollisionType SOLID, the following course of action is taken:
		
		1.	The X position is set so that the Entity is pushed against either the left or right edge
			depending on the direction of the velocity.
			
		2.	The obstructMovement boolean is set to true.
			
		Once all of the objects have been checked, the method checks the obstructMovement boolean. If
		the value is still set to false, that means no object has obstructed the movement and the
		Entity is to advance as usual, by adding the x velocity to the x value, i.e. addX(v)
		
(*)	)=================================================================================================

	dmcigd.core.objects.BlockMapCollider.java
	
		extends dmcigd.core.objects.ObjectCollider.java
		
	Similar to the ObjectCollider class, although much simpler due to the nature of the game, this
	class handles collision and the associated movement properties with blockMap collision.
	
	PUBLIC PROPERTIES
	
	->	boolean hitGround, isFalling, isDead, isDestroyed, inWater
			These booleans all mean exactly what their name implies. The only thing to note is that
			isDestroyed is called by blocks that immediately destroy the object, such as the invisible
			blocks used to line falls, preventing monsters from falling infinitely and causing memory
			leaks. isDead simply means that the Entity has hit something such as spikes, which is an
			important distinction to make as some monsters do not die from spikes.
	
	PUBLIC SETTERS
	
	->	void setBlockMap(BlockMap blockMap)
			In order to check blockMap collision, a BlockMap object is necessary. As such, the level's
			blockMap must be passed down to all Entities for collision checks.
			
	COLLISION METHODS
	
	->	CollisionType tileCollisionType(int v, Direction direction)
			Returns the CollisionType of the destination block by calling the collidesX() and
			collidesY() methods of the BlockMap as explained in special_objects
	
	->	void blockMapCollision(Direction direction)
			Places the entity at the edge of the tile in the direction it was traveling.
			This is done by calling the rowEdge() and colEdge() functions of the BlockMap as explained
			in special_objects
	
	COLLISION CHECKS
	
	Please note that a different method is called for upwards, downwards, and horizontal collision
	as they all behave in different ways.
	
	->	void checkBlockMapCollisionDown(int v)
			This method handles downward blockMap collision, as it behaves differently from all other
			directions.
			
			This method checks the tileCollisionType in the Direction.DOWN and takes a different
			course of action depending on the collisionType:
			
			WATER, NONSOLIDLADDER, or NONSOLID:
				Sets the isFalling property to true and proceeds to call the
				checkSolidObjectCollisionDown() method to proceed with object motion.
				
			DESTROY:
				Sets isDestroyed to true and falls through to default
			
			KILL:
				Sets isDead to true and falls through to default
				
			DEFAULT:
				Treats block as if it were solid.
				
				Calls the blockMapCollision(Direction.DOWN) method to obstruct the object's motion,
				sets the vertical velocity to 0, and calls the rest() as defined in ObjectCollider
			
	->	void checkBlockMapCollision(int v, Direction direction)
			This method handles all other directions of blockMap collision.
			
			This method checks the tileCollisionType in the given direction and takes the following
			courses of action based on the CollisionType:
			
			If the object is not solid, that is to say that the CollisionType's priority integer is
			greater than 1, the appropriate checkSolidObjectCollision() method is called (depending on
			the direction) to proceed with motion.
			
			Otherwise, a check is made to see if the collidingBlock is of CollisionType.DESTROY or of
			CollisionType.KILL and sets isDestroyed and isDead to true respectively.
			After that check is made, blockMapCollision(direction) is called to obstruct the movement
			and if the direction is horizontal, the horizontal velocity is set to 0.
		
(*)	)=================================================================================================

	dmcigd.core.objects.Entity.java
	
		extends dmcigd.core.objects.BlockMapCollider.java
		
	This is the object that handles the specifics of Entity instances, where BlockMapCollider and
	ObjectCollider simply run the collision checks and obstruct movement.
	
	PUBLIC GETTERS
	
	->	EntityType getEntityType()
			Returns the EntityType (as defined in enumerators)
			
	->	boolean isDestroyed()
			Used to satisfy SolidObject interface. By default, this method returns the isDestroyed
			boolean which is defined in BlockMapCollider.
			
	->	CollisionType backBlock
			Returns the CollisionType of the tile behind the Entity, used to check for water.
	
	PUBLIC SETTERS
	
	->	void setEntityType()
			Sets the EntityType (as defined in enumerators)
	
	ACTION METHODS (DEFAULT INTERACTION METHODS)
	
	->	void onPush(Entity entity, int v)
			Overrides the blank method in the ObjectCollision superclass so that Entities get pushed
			over by MOVINGBLOCK EntityTypes. If this behaviour is to be preserved but also extended,
			subclasses must call super.onPush() when defining their own onPush methods.
	
	->	void rest(CollisionType collisionType)
			Called in the move() procedure described below, as well as in block collisions in the
			parent class.
			
			Takes a different course of action depending on the collisionType:
			
				PLATFORM, SOLID, or SOLIDLADDER:
					Sets hitGround to true
					Sets isFalling to true
					
				DESTROY:
					Sets isDestroyed to true
				KILL:
					Sets isDead to true
	
	->	void pushObject(SolidObject object, int v)
			Calls the target object's onPush() method. Remember to use the super keyword if extending
			functionality.
			
	->	void restObject()
			Matches the restingBlock to the restingBlockCheck and calls the object's onRest() method
			
	->	void unrestObject()
			Calls the restingBlock's onUnrest() method and sets the restingBlock to null
	
	OBJECT PROCEDURE
	
	Much like the animate() method in AnimationHandler and the step() method in many game objects,
	Entity employs a method that is meant to be called every frame as well, which is called move().
	Within move(), the following procedure is taken:
	
	1.	Reset the Entity's status, setting inWater to false, hitGround to false, isFalling to false,
		and restingBlockCheck to null
	
	2.	Call the addAcceleration() method of the MovingObject parent class, and set the local integers
		vx and vy according to the getVX() and getVY() values.
		
	3.	The vx and vy values are modified according to the Entity's conditions. If the restingBlock is
		not null, then the restingBlock's dx and dy values are added to their respective velocities.
		
		Furthermore, if the restingBlock is null, and the Entity is inWater, then the vy is divided
		by a factor of 2.2 (to slow down falling and jumping)
		
	4.	Move the object vertically, calling checkBlockMapCollisionDown(vy) if the velocity is greater
		than or equal to zero, and calling checkBlockMapCollision(vy, Direction.UP) otherwise.
		
			These methods are explained in detail in the BlockMapCollider documentation above
		
	5.	Move the object horizontally, calling checkBlockMapCollision(vx, Direction.RIGHT) if the vx
		is greater than or equal to zero, and calling checkBlockMapCollision(vy, Direction.LEFT)
		otherwise.
		
			These methods are explained in detail in the BlockMapCollider documentation above
			
	6.	After the blockMap and subsequent solidObject collision checks are made, the restingBlockCheck
		value is checked against the current restingBlock. If the values are not equal, either
		restObject() or unrestObject() are called, depending on whether or not the value is null
		
	7.	If the restingBlock is not null, this means that the object has gotten past the blockMap
		collision check unobstructed, and must take the appropriate rest() action based on the block
		that it is resting on, so rest() is called with the restingBlock's CollisionType.
		
	8.	The backBlock property is reset based on the BlockMap's backBlock() method, and if the Entity
		is determined to be in water, then:
			Sets inWater to true
			Sets hitGround to true
	

======================================================================================================

PROJECTILE SUPERCLASSES:

BasicProjectile.java
SimpleProjectile.java

======================================================================================================

MONSTER SUPERCLASSES:

[Please note that more monster superclasses will be added to handle basic AI]

HitpointHandler.java
LethalityHandler.java

